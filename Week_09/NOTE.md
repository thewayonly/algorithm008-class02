# 学习笔记

# 高级动态规划

## 概念
动态规划，Dynamic Programming，其核心思想是把原问题分解成子问题进行求解，也就是分治的思想。

### 多阶段决策过程的最优化问题
把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题就称为多阶段决策问题。在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。当然，各个阶段决策的选取不是任意确定的，它依赖于当前面临的状态，又影响以后的发展，当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线。

## 特点
阶段：把所给求解问题的过程恰当的分成若干个相互联系的阶段，阶段是离散的，可变的。

状态：表示每个阶段开始面临的自然状况和客观条件。

无后效性：状态的这个性质意味着过程的历史只能通过当前的状态去影响它的未来的发展。

决策：一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择/行动。

策略：由每个阶段的决策组成的序列称为策略。

## 思路

1.划分状态。即划分子问题。
2.状态表示。即如何让计算机理解子问题。把现实的问题定义成一个数组，保存状态。
3.状态转移。即父问题是如何由子问题推导出来的。
DP方程: 直接递推；累加/累减；最小值；存在一层循环，从之前的K个状态中找出它的最值。
4.确定边界。确定初始状态是什么/最小的子问题/最终状态又是什么。

## 经典模型

1.线性模型。最经典的问题就是斐波那楔数列的问题，每个数的值都是一个状态，可以用F[i]表示表示第i个数的值是多少。每个数都是由F[i-1]+F[i-2]转移而来。从左往右，从上到下，从低维到高维进行转移。

2.区间模型。对于每个问题，都是由子区间推导过来的，我们称之为区间模型。

例子：
我们有一个连续的序列，每个序列上面都是一个数字c[i]，每次我们都能够消灭一个连续的回文子序列，消灭之后左右会合并，成为一个新序列，问最少需要多少次才能够把整个序列消灭掉。回文就是从左到有从右到左读到的序列都是一样的。题目比较抽象，我们通过一些例子来说明这个问题吧？例如一开始的序列是1 4 4 2 3 2 1，那么我们最少需要2次，先消灭掉4 4 ， 然后再消灭调1 2 3 2 1.第二个例子是 1 2 3 4 5 5 3 1，我们先消灭掉2 然后再消灭掉4， 最后消灭 1 3 5 5 3 1， 需要3次。

3.树状模型。在数据结构树上面进行最求最优解、最大值等问题。

## 实现的套路
一个是自底向上，另外一个是自顶向下。都要明确动态规划的过程，把状态表示、状态转移、边界都考虑好。

1.自底向上。简单来说就是根据初始状态，逐步推导到最终状态，而这个转移的过程，必定是一个拓扑序。可以轻松确定拓扑序的问题，例如线性模型，都是从左往右进行转移，区间模型，一般都是从小区间推导到大区间。自底向上的一个经典实现是斐波那楔数列的递推实现，即F[i] = F[i - 1] + F[i - 2] 。

2.自顶向下。也就是从最终状态出发，如果遇到一个子问题还未求解，那么就先求解子问题。如果子问题已经求解，那么直接使用子问题的解，所以自顶向下动态规划又有一个形象生动的名字，叫做记忆化搜索，一般采用递归的方式进行求解。

# 字符串方法

## 遍历方式
Python:
```
for ch in "abbbc":
    print(ch)
```

常见的字符串操作问题有:
1.公共子串
2.回文串
3.异或词问题

### 滑动窗口算法
可以解公共子串及异或词问题。

### KMP算法
Knuth-Morris-Pratt的思想就是，当子串与目标字符串不匹配时，其实已经知道了前面已经匹配成功的那一部分的字符（包括子串与目标字符串）。
