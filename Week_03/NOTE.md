#学习笔记

> # 二叉树的前序遍历、中序遍历、后序遍历
>> ## 二叉树的前序遍历

    二叉树的前序遍历方法很多，最容易理解的几种：

>>> * 递归方法
>>> * 使用栈的循环迭代
>>> * 莫里斯遍历

>>> ### 前序遍历递归方法


>>> ### 前序遍历利用栈循环迭代法


循环遍历时，通常要判断根元素（第一个元素）是在循环前入栈还是循环里面入栈，这里循环前入栈比较合适，
循环前入栈，while的写法是while (!deque.isEmpty())，如果循环里面入栈，while的写法是while(node != null || deque.isEmpty())


>>> ### 前序遍历莫里斯遍历



>> ## 二叉树的中序遍历

    二叉树中序遍历最容易理解的几种：

>>> * 递归方法
>>> * 使用栈的循环迭代
>>> * 利用栈的颜色遍历
>>> * 莫里斯遍历

>>> ### 使用栈的颜色遍历

对以访问过的节点做一个标志，对已访问过的节点再次访问时输出，也可以把已访问的节点再次入栈时，把左右节点设置为null来判断，但会破坏原来的数据结构。也可以设置一个vistied集合，对已访问过的节点放进集合作为判断依据。


>> ## 二叉树的后序遍历

    二叉树后序遍历最容易理解的几种：

>>> * 递归方法
>>> * 使用栈的循环迭代(先按照根右左的方式进行遍历，最后把结果逆序得到左右根顺序的后序遍历)
>>> * 利用栈的颜色遍历


>>> ### 使用栈的循环迭代



>> ## 孤岛问题

使用图的深度遍历，把访问过的节点标志为'0'，因此所有访问过的相连节点都会变成'0',下一次深度遍历的时候，表示找到一个新的'1',这个新的'1'与之前访问过的节点肯定不是相连的，因此深度优先遍历的次数就是孤岛的个数。


>> # 泛型递归、树的递归

> ### 递归模板


>> ## 爬楼梯问题

>>> #### 最简单递归解法 f(n) = f(n-2) + f(n-1)


>>> ### 带有记忆数组的递归方法


>>> ### 带有记忆数组的循环方法


>>> ### 不保留中间结果的循环


>>> ### 递推法  f(i,n) = f(i+1,n) + f(i+2,n)


------------------------
>> ## 括号生成问题


>>> * 深度优先算法容易理解，实现也简单
>>> * 广度优先算法效率较差，需要自己维护队列，定义队列元素结构
>>> * 动态规划算法有两种实现，为了优化都需要存储中间状态：
>>>> * 一种是自顶向下，范围逐渐缩小，f(n）->f(n-1)->f(n-2)...f(1)->f(0)
>>>> * 一种是自底向上，范围逐渐扩大, f(0)->f(1)->...->f(n)


------------------------
>> ## 二叉树的最近公共祖先问题

>>> #### 暴力解法1

求出根节点到p所经过的所有路径，求出根节点到q所经过的所有路径，再对两条路径两层循环，求公共节点。


>>> #### 暴力解法2

求出根节点到p所经过的所有路径p1，从下往上遍历p1,寻找从经过的节点出发，是否能找到另一个节点q。


>>> ### 基于节点条件递归深度遍历 

深度遍历每一个节点，左子树，右子树，节点本身三个之中任意两个含有p与q，那么这个节点就是公共节点。

>>> ### 有父指针的迭代

>>> ### 无父子针的迭代



>> ## 从前序和中序遍历序列构造二叉树

把问题分解为多个子问题进行求解，要注意边界问题很容易混淆。
原来的思路和每次要求出前序遍历的子集，实时上不用，初始的前序遍历的顺序就是深度遍历每一棵子树的根节点的顺序。


------
>> ## 组合问题 
>给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。


>>> #### 回溯法


>>> ### 对上一版本的优化
>考虑剩余空间，最大能放的值，提前剪枝


--------

>> ## 全排序问题


分为两种情况，

* 不含重复元素



* 含有重复元素



含有重复元素时，首先排序，使得相同元素连在一起。选择元素的时候，判断该元素是否重复，并且被使用多次，根据这个条件进行剪枝。


>>> ### C++使用stl简洁解法


----

>> ## 翻转一颗二叉树

使用递归方法容易实现。还可以使用广度优先队列求解，入队前交换左右节点。

>> ## 最小基因变化


这里使用了深度优先算法，其实跟单个字符取什么值没有关系，关键是只要替换一个值，能在基因库找到或找不到。
基因库的值就是候选值，对候选值进行回溯尝试，终止条件是找到目标值，或候选值全部访问过了也找不到。

这里还可以使用广度优先队列方法求解。使用双重循环。外层循环是队列是否为空，内层循环是只改变一个字符，队列中的元素进行循环。


>> ## 求二叉树的最大深度

>> * 方法1


>> * 方法2



>> ## 二叉树的序列化与反序列化

>> * 使用完全二叉树的方法，使用数组作为底层数据结构，与堆的构造类似，该方法执行到47/48个测试例子时显示内存超出范围。

>> * 使用前序遍历方式，把访问过的节点记录下来序列化；反序列化也是同样的方式。这里用了一个重要的数据结构是LinkedList,可以双向插入，删除。



> # 分治和回溯

分治和回溯就是递归，分治把一个大问题分解为很多个小问题，找重复性。最后合并。

分治代码模板：


>> ## pow(x,n)问题

>> * 暴力法
会超时

>> * pow(x,n) = pow(x, n/2) * pow(x, n/2) 或  pow(x,n) = pow(x, n/2) * pow(x, n/2) * x



>> ## 子集问题

>> * 方法一：递归
思路

开始假设输出子集为空，每一步都向子集添加新的整数，并生成新的子集。

>> * 方法二：回溯
算法

幂集是所有长度从 0 到 n 所有子集的组合。

根据定义，该问题可以看作是从序列中生成幂集。

遍历 子集长度，通过 回溯 生成所有给定长度的子集

>> * 方法三：字典排序（二进制排序） 子集
思路

该方法思路来自于 Donald E. Knuth。

将每个子集映射到长度为 n 的位掩码中，其中第 i 位掩码 nums[i] 为 1，表示第 i 个元素在子集中；如果第 i 位掩码 nums[i] 为 0，表示第 i 个元素不在子集中。


>> ## n皇后问题

最直观的方法是使用回溯法求解，这里也是使用回溯法，还有用位运算求解的，这个后面再论述。

n皇后问题其他逻辑是比较清晰的，比较容易找规律，边界条件也容易把握。


